## 구간 합 구하기

구간 합은 누적 합을 이용해서 구할 수 있음. 예를들어 a ~ b 사이의 구간 합을 구하려고 할 때,  
첫번째 수부터 b번째 수까지 더한 값에서 첫번째 수부터 a - 1번째 수까지 더한 값을 뺴준 것과 같음  
따라서 리스트에 각 인덱스까지의 누적합을 담아두고, `list[b] - list[a - 1]` 로 a ~ b까지의 구간 합을 구할 수 있음.

## 다익스트라

다익스트라 알고리즘은 시작 정점에서 각 정점까지의 최단거리를 구하는 알고리즘임
다익스트라 알고리즘은 deque가 아닌 heapq를 사용하는데 heapq에 넣을 때는 (가중치, 노드 번호) 이런 식으로 가중치를 첫 번째 값으로 넣어줌

```python
def dijkstra(k):
    queue = []
    weights[k] = 0 # 자기 자신으로 가는 값은 0
    heappush(queue, (0, k)) # 가중치를 첫 번째 값으로, 노드 번호를 두 번째 값으로 넣음

    while queue:
        weight, node = heappop(queue)

        if weights[node] < weight: # 기존에 계산한 최단거리보다 가중치가 더 높다면 무시
            continue
        for w, node in graph[node]:
            next_w = weight + w

            if next_w < weights[node]: # 기존에 계산한 최단거리보다 가중치가 작다면
                weights[node] = next_w
                heappush(queue, (next_w, node))
```

위의 코드처럼 현재까지 알고 있던 시작 노드에서 각 노드로 가는 최단거리를 계속해서 갱신함

## 플로이드-워셜

다익스트라 알고리즘이 시작 노드에서 모든 노드까지의 거리를 구하는 알고리즘이라면,
플로이드-워셜 알고리즘은 모든 노드에서 모든 노드까지의 최단거리를 구하는 알고리즘임

```python
for k in range(1, n + 1):
    for i in range(1, n + 1):
        for j in range(1, n + 1):
            graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])
```

위의 코드가 플로이드-워셜의 키가 되는 코드라고 보면 되는데, graph[x][y]에는 x에서 y로 가는 비용이 담겨있음.

```python
graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])
```

이 부분을 보면 결국 i에서 j로 바로가는 비용과 i에서 k로 가고, k에서 j로 가는 비용을 더한 값을 비교해서 더 작은 값으로 비용을 업데이트 해주는 것임 이것을 반복해서 결국에는 각 노드에서 모든 노드로 가는 최단거리를 구할 수 있음

## 벨만-포드

시작 정점으로부터 다른 정점까지의 최단 경로를 찾는 알고리즘

```python
dist[start] = 0 # 시작 노드에 대해서 거리를 0으로 초기화
    for i in range(n): # 정점 수만큼 반복, n은 노드의 수
        for j in range(m): # 매 반복 마다 모든 간선 확인, m은 간선의 수
            node, next_node, cost = graph[m]
            # 현재 간선을 거쳐서 다른 노드로 이동하는 거리가 더 짧은 경우
            if dist[node] != INF and dist[next_node] > dist[node] + cost:
                dist[next_node] = dist[node] + cost
                if i == n-1: # n-1번 이후 반복에도 값이 갱신되면 음수 순환 존재
                    return True
    return False
```

1. 시작 정점 결정
2. 시작 정점으로부터 다른 정점까지의 거리를 무한대로 초기화 (자기 자신으로의 거리는 0)
3. 현재 정점에서 모든 인접 정점들을 탐색하며, 기존에 저장된 인접 정점까지의 거리와 비교해 짧은 거리로 갱신
4. 3번을 정점의 수 - 1번 반복
5. 정점의 수 - 1번 반복한 후에도 거리가 갱신된다면 음수 사이클이 존재한다는 뜻

## BFS를 이용하여 구역의 수 구하기

2667.단지번호붙이기, 10026.적록색약 등의 문제 처럼 그래프에서 어떤 규칙을 가진 구역의 수를 구할 때

```python
for i in range(n):
    for j in range(n):
        if not visited[i][j] and 특정 조건(ex)단지번호붙이기. graph[i][j] == 1):
            bfs(i, j)
            count += 1
```

위의 코드처럼 모든 정점을 기준으로 주변을 탐색하는데, 시작지점 (i, j)를 기준으로 인접한 지역을 탐색하므로 한번의 탐색이 끝날 때마다 하나의 구역이 생성된다고 생각하면 됨. 따라서 bfs가 한번 실행 될 때마다 count의 값을 1씩 더해주어 총 몇개의 구역이 생성되는지 구할 수 있음.

## BFS의 탐색 속도 최적화

특정한 경우에 BFS 탐색에 사용하는 큐를 두개 사용하면 시간을 줄일 수 있음.  
하나의 큐에는 현재 BFS사이클에서 탐색할 수 있는 좌표를 넣고, 다른 큐에는 현재 BFS사이클에서는 탐색할 수 없지만 다음 사이클에서 탐색할 수 있는 좌표를 넣는 식.

예를들어 3197.백조의 호수 문제처럼 얼음은 물과 닿아있으면 다음 날에 녹고 백조는 물로만 이동할 수 있다고 할 때, 하나의 큐에는 물이라서 이동가능한 다음 탐색위치를 (nx, ny) 넣고, 탐색 진행 도중에 얼음인 부분을 만나면 그 곳은 다음 탐색의 시작점이기 때문에 다른 큐에 담아줌. 그리고 다음 BFS 실행전에 얼음이 담겨있던 큐를 다른 큐에 넣어주는 식으로 그래프의 모든 부분을 매번 탐색해서 시작위치를 찾는 것이 아니라 다음 시작위치를 미리 찾아둠으로써 시간이 줄어듬

## 트리의 지름 구하기

트리의 지름은 임의의 두 점 사이의 거리 중 가장 긴 것인데, 이는 BFS 또는 DFS로 임의의 한 점에서 가장 먼 점을 찾고, 그 점을 기준으로 다시 한번 가장 먼 점을 찾았을 때 그 거리가 트리의 지름임

## if문 풀어서 쓰기

```python
if a:
    print()
    if b:
        print()
        if c:
            print()
            if d:
                print()
            else:
                exit(0)
        else:
            exit(0)
    else:
        exit(0)
else:
    exit(0)
```

이것 보다는

```python
if !a:
    exit(0)
if !b:
    exit(0)
if !c:
    exit(0)
if d:
    print()
```

이게 가독성이 좋음

## list의 슬라이싱

list 슬라이싱은 알고있었지만
이런 것도 되는줄은 몰랐음

```python
list(map(int, input().split()))[1:]
```

## 값을 입력 받을 때

[1,2,3,4] 이런식으로 괄호와 쉼표까지 리스트의 형태로 입력이 들어올 때 괄호와 쉼표를 제외한 숫자들만 입력받고 싶다면,

```python
numbers = list(input().rstrip()[1:-1].split(','))
```

이런식으로 처리할 수 있음.
`input()`으로 입력받은 리스트 ['[', 1, ',', 2, ',', 3, ',', 4, ']']에서 `rstrip()[1:-1]`로 양 끝의 '[', ']' 을 제외한 뒤 `split(',')`으로 ','를 구분자로해서 값들을 잘라줌 결국 리스트는 [1, 2, 3, 4] 형태가 됨

## 다리 놓기 경우의 수

조건

- 한 사이트에는 최대 한개의 다리만 연결될 수 있음(중복x)
- 다리끼리는 서로 겹쳐질 수 없음

위의 조건을 만족하면서 M개의 지역에 N개의 다리를 놓는다는 것은 결국 M개 중에서 N개를 선택하는 것이므로, 조합 공식으로 풀 수 있음  
`factorial(M) // (factorial(N) * factorial(M - N))`  
위의 공식을 이용해서 구할 수 있음.

## DP 문제 이중 리스트 사용

백준 10844.쉬운 계단 수 처럼 (12321 처럼 서로 인접한 수의 차이가 모두 1인 숫자의 수를 찾는 문제)  
|자릿수|0|1|2|3|4|5|6|7|8|9|
|-|-|-|-|-|-|-|-|-|-|-|
|1의 자리 |0|1|1|1|1|1|1|1|1|1|
|10의 자리 |1|1|2|2|2|2|2|2|2|1|
|100의 자리|1|3|3|4|4|4|4|4|3|2|
이런 식으로 dp[자리수][숫자]의 형태로 dp 테이블을 만들면 이해하기 편한 경우가 있다.

## 음수인 홀수의 나눗셈

```python
print(-1 * 11 // 2) # 결과 -6
print(-1 * (11 // 2)) # 결과 -5
```

확실하지는 않지만 음수인 홀수에 나누어 떨어지지 않는 // 연산을 진행하면 반내림을 하는 것 같고,
양수인 홀수에 나누어 떨어지지 않는 // 연산을 진행하면, 반올림을 하는 것 같음.  
두가지의 결과가 다르니 주의할 것.

## LIS 가장 긴 증가하는 부분 수열

```python
n = int(input()) # 카드의 개수 n
cards = list(map(int, input().split()))

answer = [float('inf')] * n

for i in range(n):
    index = bisect_left(answer, cards[i]) # answer에서 cards[i]를 insert 할 때 그 위치의 인덱스
    answer[index] = cards[i]
```

answer에 어떤 값이 들어가 있느냐가 중요한 게 아니라  
answer에 inf가 아닌 값의 길이가 중요한 것

9  
6 4 5 3 5 6 7 1 2

예를 들어 위의 예시의 경우 결국 마지막에 answer에 들어있는 값은
[1, 2, 6, 7, inf, inf, inf, inf, inf]  
입력값에서 1, 2, 6, 7 이라는 순증가 수열은 없지만
중요한 것은 어떤 값이 들어 있느냐가 아니라 가장 길었던 순증가 수열의 길이이므로,
7까지의 길이인 4가 정답인 것임
